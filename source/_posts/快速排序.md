title: 1.快速排序
author: 辛同学
tags: []
categories:
  - 算法
date: 2020-03-08 16:24:00
---
# 快速排序


* 参考资料   
B站资料--->[链接](https://www.bilibili.com/video/av39093184?t=256,主要是看过程图)
---
* 主要思路：  

&nbsp;假设一个数组 int arr {3,2,6,5,1,4}  

1. 这边我们先取出一个数 我这边取出数组的第一个 arr[0] 也就是3(有些人是取最后一个数，一样的）  
2. 我们需要找到一个index ,在index左边，数组都小于arry[index],右边都大于arry[index].（在找的过程中可以改变数组元素）也就是{1,2,3,5,6,4}
  		方法：2个数纪录位置 start 和end  start =0+1，end =5；  
                 从后面开始比较，如果arr[end]>3 end就减1继续比较;因为比3大在右边是正确的
                 遇到arr[end]<3 ;这个时候停下来。从前面来
                 与后面比较相反。如果arr[end]<3 star就+1继续比较;因为比3小在左边是正确的
                 遇到arr[start]>3; 这个时候停下来

                 注意前面end位置那个数是比3小，此时start位置比3大，把2个数交换下位置吧
                 这样2个这个时候数组会变成{3，2，1，5，6，4} 
                 把end减1 从后面比较，形成循环。
                 注意: 循环的条件是start<end  ,比较时候用的循环也有这个条件
                 
                 循环结束后 一定是start==end
                 这个时候数组是{3，2，1，5，6，4} start==end =2
                 
                 再把arr[0]和arr[2]比较  如果arr[0]小就不用交换位置，反之交换
                 这个时候start =2 就是第2步要的index
                 交换后就是数组{1,2,3,5,6,4}，同时也得到index3.
                 可以这么想，3此时的位置就是排序最后的位置  
 3. 接下来就是3的左边和右边继续找index的位置，每次都能找到一个index的位置  
 就是{1，2}和{5，6，4}，再做一个递归就可以完成整个数组的排序  
 
 ----
 # 思考过的问题
 
 1. 在步骤2中，移动end的时候如果遇到等于怎么办，start同理 
 2. 在看视频的过程中，发现找到index位置后是不用判断数组第一个元素和index元素大小，直接交换的。是这样的吗？
 ---
 * 关于第一个问题，可以这么想。我们关注的是!    
 找到一个index ,在index左边，数组都小于arry[index],右边都大于arry[index].  
 至于等于。我们可以看成是小于或是大于。都没关系。因为在左边和右边都没关系。我们关注的是！  
 找到一个index。。。。。
  
 * 关于第二个问题 ，假如数组是 {2，6}  按步骤来，2和6就会交换位置 最后导致不符合要求，  
 index =1，但不是我们前面提到关注的东西
---
 # 代码,附带测试程序
 
 ``` code
 #include <iostream>  ////环境是VS2013  C++
using namespace std;

template<typename T>
int fastorder(T* arr,int start,int end)
{
	int index = 0;
	T temp;
	if (start >= end)
		return 0;
	index = getindex(arr, start, end);
	if (arr[start]>arr[index])
	{
		temp = arr[index];
		arr[index] = arr[start];
		arr[start] = temp;
	}
	fastorder(arr, start ,index-1);
	fastorder(arr, index+1,end);


	return 0;
}
template<typename T>
int getindex(T* arr, int start, int end)
{
	T target = arr[start];
	int ss = start;
	T temp;
	start++;
	while (start < end)
	{
		while (start<end && arr[end]>target)
		{
			end--;
		}

		while (start<end && arr[start]<target)
		{
			start++;
		}
		if (start != end)
		{
			
			temp = arr[end];
			arr[end] = arr[start];
			arr[start] = temp;
				end--;
		}


	}

	return start;
}

int main()
{

	//int arr[] = { 3, 2, 6, 5, 1, 4 };
	//int arr[] = { 3, 2, 2, 2, 2, 1 };

	int arr[] = { 2, 6 };

	fastorder(arr, 0, 1);


	for (int i = 0; i < 2; i++)
	{
		cout << arr[i] << endl;
	}
	getchar();
	return 0;
}
 ```